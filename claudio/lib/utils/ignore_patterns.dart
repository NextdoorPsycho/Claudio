import 'dart:io';
import '../models/language_config.dart';

/// Utility class for handling ignore patterns
class IgnorePatterns {
  /// Common generated file markers for C-style comments
  static final List<RegExp> cStyleGeneratedMarkers = [
    RegExp(r'///\s*This file is automatically generated\.?\s*DO NOT EDIT'),
    RegExp(r'///\s*GENERATED CODE\s*-\s*DO NOT MODIFY BY HAND'),
    RegExp(r'//\s*File generated by FlutterFire CLI\.'),
    RegExp(r'///\s*This file is automatically generated\.'),
    RegExp(r'///\s*FlutterGen'),
    RegExp(r'//\s*GENERATED CODE\s*-\s*DO NOT MODIFY'),
    RegExp(r'//\s*coverage:ignore-file'),
    RegExp(r'//\s*ignore_for_file:.*generated'),
    RegExp(r'//\s*AUTO-GENERATED'),
    RegExp(r'//\s*@generated'),
    RegExp(r'/\*\s*AUTO[- ]?GENERATED'),
    RegExp(r'//\s*This file was automatically generated'),
  ];

  /// Generated markers for Python-style comments
  static final List<RegExp> pythonGeneratedMarkers = [
    RegExp(r'#\s*AUTO[- ]?GENERATED'),
    RegExp(r'#\s*This file is automatically generated'),
    RegExp(r'#\s*DO NOT EDIT'),
    RegExp(r'#\s*Generated by'),
    RegExp(r'#\s*@generated'),
    RegExp(r"'''[\s\S]*?AUTO[- ]?GENERATED[\s\S]*?'''"),
    RegExp(r'"""[\s\S]*?AUTO[- ]?GENERATED[\s\S]*?"""'),
  ];

  /// Generated markers for hash-style comments
  static final List<RegExp> hashGeneratedMarkers = [
    RegExp(r'#\s*AUTO[- ]?GENERATED'),
    RegExp(r'#\s*This file is automatically generated'),
    RegExp(r'#\s*DO NOT EDIT'),
    RegExp(r'#\s*Generated by'),
    RegExp(r'#\s*@generated'),
  ];

  /// Generated markers for HTML comments
  static final List<RegExp> htmlGeneratedMarkers = [
    RegExp(r'<!--\s*AUTO[- ]?GENERATED\s*-->'),
    RegExp(r'<!--\s*This file is automatically generated\s*-->'),
    RegExp(r'<!--\s*DO NOT EDIT\s*-->'),
  ];

  /// Check if a path matches any of the given glob-like patterns
  static bool matchesPattern(String filePath, List<String> patterns) {
    final normalizedPath = filePath.replaceAll('\\', '/');

    for (final pattern in patterns) {
      if (_matchGlobPattern(normalizedPath, pattern)) {
        return true;
      }
    }
    return false;
  }

  /// Simple glob pattern matching
  static bool _matchGlobPattern(String path, String pattern) {
    // Handle exact file extension match (e.g., *.g.dart)
    if (pattern.startsWith('*.')) {
      return path.endsWith(pattern.substring(1));
    }

    // Handle directory wildcards (e.g., */generated/*)
    if (pattern.contains('*')) {
      final regexPattern = pattern
          .replaceAll('.', r'\.')
          .replaceAll('*', '.*')
          .replaceAll('?', '.');
      return RegExp(regexPattern).hasMatch(path);
    }

    // Exact match
    return path == pattern || path.endsWith('/$pattern');
  }

  /// Check if file content contains generated file markers
  static bool hasGeneratedMarker(String content, CommentStyle style) {
    // Only check the first 50 lines for performance
    final lines = content.split('\n');
    final linesToCheck = lines.take(50).join('\n');

    final markers = _getMarkersForStyle(style);

    for (final marker in markers) {
      if (marker.hasMatch(linesToCheck)) {
        return true;
      }
    }
    return false;
  }

  /// Get the appropriate markers for a comment style
  static List<RegExp> _getMarkersForStyle(CommentStyle style) {
    switch (style) {
      case CommentStyle.cStyle:
        return cStyleGeneratedMarkers;
      case CommentStyle.pythonStyle:
        return pythonGeneratedMarkers;
      case CommentStyle.hashStyle:
        return hashGeneratedMarkers;
      case CommentStyle.htmlStyle:
      case CommentStyle.mixedWeb:
        return [...htmlGeneratedMarkers, ...cStyleGeneratedMarkers];
    }
  }

  /// Get the reason a file should be ignored
  static String? getIgnoreReason(
    String filePath,
    String? content,
    List<String> patterns,
    List<String> exactFiles, {
    CommentStyle style = CommentStyle.cStyle,
  }) {
    final normalizedPath = filePath.replaceAll('\\', '/');

    // Check exact file matches
    for (final file in exactFiles) {
      if (normalizedPath == file || normalizedPath.endsWith('/$file')) {
        return 'In ignore files list';
      }
    }

    // Check patterns
    for (final pattern in patterns) {
      if (_matchGlobPattern(normalizedPath, pattern)) {
        return 'Matches pattern: $pattern';
      }
    }

    // Check generated markers in content
    if (content != null && hasGeneratedMarker(content, style)) {
      return 'Contains generated file marker';
    }

    return null;
  }

  /// Check if a file should be ignored based on all criteria
  static Future<IgnoreResult> shouldIgnore(
    File file,
    String relativePath,
    List<String> patterns,
    List<String> exactFiles, {
    CommentStyle style = CommentStyle.cStyle,
  }) async {
    // First check patterns (fast, no I/O)
    final patternReason = getIgnoreReason(
      relativePath,
      null,
      patterns,
      exactFiles,
      style: style,
    );
    if (patternReason != null) {
      return IgnoreResult(true, patternReason);
    }

    // Then check file content for generated markers (requires I/O)
    try {
      final content = await file.readAsString();
      if (hasGeneratedMarker(content, style)) {
        return const IgnoreResult(true, 'Contains generated file marker');
      }
    } catch (e) {
      return IgnoreResult(true, 'Could not read file: $e');
    }

    return const IgnoreResult(false, null);
  }
}

/// Result of an ignore check
class IgnoreResult {
  final bool shouldIgnore;
  final String? reason;

  const IgnoreResult(this.shouldIgnore, this.reason);
}
